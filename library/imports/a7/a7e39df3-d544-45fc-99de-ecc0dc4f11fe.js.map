{"version":3,"sources":["assets\\frame\\scripts\\SDK\\T2M.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["/**\n * v2.2\n * Author: jinhailiang\n * Email: jinhailiang@tal.com\n * update-1.0: 2020_04_05:构建\n * update-1.1: 2020_10_29:用数组管理reducer，便于多个组件之间进行事件传输；\n * update-1.2: 2020_12_08:添加心跳同步和动作验证；\n * update-2.0: 2021_03_19:代码重构：核心功能解藕-此版本专注于实现游戏异步事件的管理；\n *              1.结构优化-更改API，用户可以按使用单机游戏事件管理器的方式使用此模块。\n *              2.通过增加待运行的事件队列解决偶现的动作执行错序问题。\n *              3.去除心跳同步，心跳同步作为普通异步事件的特例留给用户自定义。\n *              4.去除网络导致的动作错序验证，上层网络导致的动作错序和丢失问题 1）留给心跳同步解决 2）需对上层网络协议重新选择或优化。\n *              5.新增网络堵塞时，抛弃非关键数据功能。\n * update-2.1: 2021_04_06:无论是否同步操作方都直接调用回调函数；\n * update-2.2: 2021_04_07:去除action上携带的时间戳及关键数据标记，接收端通过update依次执行队列中的action，避免使用settimeout出现事件队列阻塞的问题；\n *\n * detail: T2M(type to method)用来管理数据同步，派发action时执行相应的方法。借助此模块，用户可以用开发单机游戏的方式开发同步游戏；\n * 跟开发单机游戏的区别：\n * 1. 反应速度-单机游戏是即时反应，同步游戏需要等一段时间，这段时间包括本模块为降低发送频率所设计的50ms的缓存时间和网络传输消耗的时间。\n */\n\nimport { FrameMsgType } from '../Data/FrameMsgType';\nimport { NetWork } from '../Http/NetWork';\nimport { ListenerManager } from '../Manager/ListenerManager';\nimport { ReportManager } from '../Manager/ReportManager';\nimport { SyncData, SyncDataManager } from '../Manager/SyncDataManager';\nimport { UIHelp } from '../Utils/UIHelp';\nimport GameMsg from './GameMsg';\n\nexport class Action {\n    type: string = '';\n    syncData: SyncData = JSON.parse(JSON.stringify(SyncDataManager.getSyncData()));\n    data: any = null;\n}\n\nexport class SendData {\n    isHeartBreak: boolean = false;\n    data: Action[] = [];\n\n    constructor(isHeartBreak?: boolean, data?: Action[]) {\n        this.isHeartBreak = isHeartBreak || false;\n        this.data = data || [];\n    }\n}\n\nexport class T2MClass {\n    private static _instance: T2MClass = null;\n\n    private _map: Map<string, Function> = new Map();\n    private _isSync: Boolean = false;\n    private _isInit: Boolean = false;\n    private _cacheList: Array<Action> = [];\n    private _lastSendTime: number;\n    private _lastUpdateTime: number;\n    private _waitRunActionList: Array<Action> = [];\n    private _sendTime: number = 0;\n    private _lastEventTime: number = 0;\n    public isRecover: boolean = false;\n    private _heartCount: number = 0;\n    private _heartInterval: number = 1000;\n    private readonly _fastHeartCount = 4;\n\n    public static getInstance() {\n        if (this._instance == null) {\n            this._instance = new T2MClass();\n        }\n        return this._instance;\n    }\n\n    /**\n     * 初始化：gamemsg注册监听事件，初始化发送时间\n     */\n    public init() {\n        this.setSync(NetWork.isSync);\n        if (!this._isInit) {\n            GameMsg.recv_sync_data(this.actionSyncHandler.bind(this));\n            // GameMsg.recv_sync_3s_data(this.onHeartBreakHandler.bind(this));\n            this._lastSendTime = Date.now();\n            this.addSyncEventListener(FrameMsgType.ON_HEART_BREAK, this.onHeartBreak.bind(this));\n            this.setFastHeartBreakState();\n            this._isInit = true;\n            GameMsg.request_sync_init();\n        }\n    }\n\n    public onReturnToTeacherPanel() {\n        this._isSync = false;\n    }\n\n    /**\n     * 设置是否派发同步事件\n     * @param isSync  为true时发送同步事件，否则发送单机事件\n     */\n    public setSync(isSync: boolean) {\n        this._isSync = isSync;\n    }\n\n    /**\n     * 为事件类型注册监听器\n     * @param type  监听的事件类型\n     * @param listener  监听器回调函数\n     */\n    public addSyncEventListener(type: string, listener: Function) {\n        this._map.set(type, listener);\n    }\n\n    /**\n     * 移除事件监听\n     * @param type  事件类型\n     */\n    public removeSyncEventListener(type: string) {\n        if (this._map.has(type)) {\n            this._map.delete(type);\n        }\n    }\n\n    /**\n     * 派发事件，接收端接收到事件后会触发对应的回调函数\n     * @param type  事件类型\n     * @param data  发送的数据\n     * @param addCache  是否放入缓存。当设置为true时，会将派发的事件放入一个缓存队列中，等一段时间后统一发送；当设置为false时，会立即派发。拖拽事件建议设置为true。\n     */\n    public dispatch(type: string, data: any, addCache: boolean = true) {\n        let syncAction = new Action();\n        syncAction.type = type;\n        syncAction.data = data;\n        if (this._isSync) {\n            if (FrameMsgType.ON_HEART_BREAK === type) {\n                let sendData = new SendData(true, [syncAction]);\n                GameMsg.send_sync_data(sendData);\n            } else {\n                // 非心跳事件不发全量数据\n                syncAction.syncData = null;\n                if (addCache) {\n                    this._cacheList.push(syncAction);\n                } else {\n                    let sendData = new SendData(false, [syncAction]);\n                    GameMsg.send_sync_data(sendData);\n                }\n            }\n            this._sendTime = Date.now();\n        } else {\n            if (this._map.has(type)) {\n                if (FrameMsgType.ON_HEART_BREAK !== type) {\n                    this._map.get(type)(data);\n                }\n            } else {\n                console.log(`Listener type is null! type = ${type}`);\n            }\n        }\n    }\n\n    /**\n     * 监听心跳\n     * @param data\n     */\n    private onHeartBreak(data: SyncData) {\n        if (SyncDataManager.syncData.frameSyncData.actionId !== data.frameSyncData.actionId) {\n            ListenerManager.dispatch(FrameMsgType.ON_RECOVERY_DATA, data);\n        }\n\n        if (!this.isRecover) {\n            this.isRecover = true;\n            UIHelp.closeRecoverMask();\n\n            // -999为接着玩预留字段，取消接着玩时不发送 ON_FIRST_BREAK 事件\n            if (-999 !== data.frameSyncData.actionId) {\n                ListenerManager.dispatch(FrameMsgType.ON_FIRST_BREAK, null);\n            }\n\n            // 检测心跳数据量，过大给提醒\n            const dataStr = JSON.stringify(data);\n            console.log('SyncData length: ', dataStr.length);\n            if (dataStr.length > 1024 * 5) {\n                console.warn('心跳数据量过大！ dataStr.length: ', dataStr.length);\n            }\n        }\n    }\n\n    /**\n     * 1.发送端通过心跳发送缓存事件，每隔一段时间(50ms)发送一次缓存队列；\n     * 2.接受端执行待执行缓存队列中的action；\n     * 3.使用时需要在组件的update周期函数中调用此函数；\n     */\n    public update() {\n        if (!this._isInit) return;\n\n        this.sendSyncEvent();\n        this.sendHeartBreak();\n        this.runActions();\n    }\n\n    /**\n     * 发送事件\n     */\n    private sendSyncEvent() {\n        if (Date.now() - this._lastSendTime >= 50) {\n            if (this._cacheList.length > 0) {\n                let sendData = new SendData(false, this._cacheList);\n                GameMsg.send_sync_data(sendData);\n                this._cacheList = [];\n                this._sendTime = Date.now();\n            }\n            this._lastSendTime = Date.now();\n        }\n    }\n\n    public setFastHeartBreakState() {\n        this._sendTime = 0;\n        this._heartCount = 0;\n        this._heartInterval = 1000;\n    }\n\n    /**\n     * 发送心跳包\n     */\n    private sendHeartBreak() {\n        if (Date.now() - this._sendTime > this._heartInterval && (NetWork.isSupportKeepPlay || NetWork.isMaster)) {\n            // const syncData = SyncDataManager.getSyncData();\n            this.dispatch(FrameMsgType.ON_HEART_BREAK, null, false);\n            this._sendTime = Date.now();\n            ++this._heartCount;\n            if (this._fastHeartCount === this._heartCount) {\n                this._heartInterval = 3000;\n            }\n            cc.log('sendHeartBreak');\n        }\n    }\n\n    /**\n     * 接受端接收到数据时的回调\n     */\n    private actionSyncHandler(data: any) {\n        let actions = data.data.data;\n\n        // 重新玩或接着玩时，如果播放器拿不到心跳数据，会发一个内容为null的心跳\n        if (!actions) {\n            let tmpAction = new Action();\n            tmpAction.type = FrameMsgType.ON_HEART_BREAK;\n            actions = [tmpAction];\n            data.data.data = actions;\n            this.onHeartBreakHandler(data);\n            return;\n        }\n\n        if (1 === actions.length && FrameMsgType.ON_HEART_BREAK === actions[0].type) {\n            if (!NetWork.isMaster) {\n                this.onHeartBreakHandler(data);\n            }\n            return;\n        }\n\n        // 接着玩兼容旧端 学生端接收到第一次心跳后才处理同步事件\n        if (NetWork.isSupportKeepPlay || NetWork.isMaster || this.isRecover) {\n            if (this._waitRunActionList.length == 0) {\n                this._waitRunActionList = [...actions];\n            } else {\n                this._waitRunActionList = [...this._waitRunActionList, ...actions];\n            }\n            this._lastEventTime = Date.now();\n        }\n    }\n\n    /**\n     *\n     * @param data 接收心跳数据\n     */\n    private onHeartBreakHandler(data: any) {\n        let actions = data.data.data;\n        // 收到操作事件2S内不处理心跳（防止旧的心跳数据覆盖当前状态）\n        if (Date.now() - this._lastEventTime > 2000) {\n            if (this._waitRunActionList.length == 0) {\n                this._waitRunActionList = [...actions];\n            } else {\n                this._waitRunActionList = [...this._waitRunActionList, ...actions];\n            }\n        }\n    }\n\n    /**\n     * 依次运行缓存中的action\n     */\n    private runActions() {\n        let waitRunActionsNum = this._waitRunActionList.length;\n        if (waitRunActionsNum > 0) {\n            let updateTime = Date.now() - this._lastUpdateTime;\n            let minEnterTimePerAction = 7;\n            let maxNeedRunActionNum = Math.floor(updateTime / minEnterTimePerAction);\n            let runNum = Math.min(waitRunActionsNum, maxNeedRunActionNum);\n            let action = this._waitRunActionList[0];\n            if (FrameMsgType.ON_HEART_BREAK !== action.type) {\n                for (let i = 0; i < runNum; i++) {\n                    let action: Action = this._waitRunActionList.shift();\n\n                    if (this._map.has(action.type)) {\n                        this._map.get(action.type)(action.data);\n                    }\n\n                    ++SyncDataManager.syncData.frameSyncData.actionId;\n                }\n            } else {\n                this._waitRunActionList.shift();\n                this._map.get(action.type)(action.syncData);\n            }\n        }\n        this._lastUpdateTime = Date.now();\n    }\n}\n\nexport const T2M = T2MClass.getInstance();\n"]}